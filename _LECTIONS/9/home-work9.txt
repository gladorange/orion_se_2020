В этот раз два задания на выбор. Если вы сделали игру про магов - можете делать 9.2 или 9.1

Задание 9.Аннотации и рефлексия

Аннотированная де\сериализация.

Создайте метод String serialize(Collection<?> object), который может записывать любые объекты в формате XML:
- Объект начинается с тэга, описывающий имя класса.
- Свойства объектов заключаются в открывающие и закрывающие тэги

- Создайте аннотацию @XmlName, чтобы определять имя свойства
- Создайте аннотацию @XmlIgnore, чтобы исключить поля из сериализации
- Создайте аннотацию @XmlTypeName, чтобы определять имя объекта контейнера

Например, класс
@XmlTypeName("Человек")
class Person {

    @XmlName("Имя")
    String firstName="Vasya";

    @XmlName("Возраст")
    double age=12

    @XmlIgnore
    String password;
}

будет выглядеть так
<Человек>
    <Имя>Vasya</Имя>
    <Возраст>12</Возраст>
</Человек>


Создайте класс, который может читать любой объект в формате XML.
например ,deserialize(<пример выше>, Person.class) вернет экземпляр Person{name="Vasya",age=12,password=null}


Создайте несколько объектов разных классов, запишите и прочитайте их из XML.

Для простоты реализации договоримся, что сериализоваться\десериализоваться будут только поля следующих типов: строки, числа, Boolean.
Вложенные сложные объекты можно игнорировать. Для того, чтобы класс был сериализуемым - обязательно, чтобы у него был конструктор без параметров.





Задание 9.1 Файловый менеджер
Создать консольный файловый менеджер который позволит:
1. Показать текущую директорию
2. Показать все вайлы в текущей диркетории
3. Сменить директорию на другую
4. Вывести содержимое указанного файла.


Задание 9.2 Маги в сохранности!

Помните, в четвертом задании я  просил делать игру про магов максимально расширяемой?
 Теперь пришло время проверить вашу дальновидность.

Ваша игра завоевала популярность и игроков и они просят вас об одной функции:
- Добавить возможность "просматривать" уже завершенные игры.

Это значит, что при завершении игры возникает вопрос: "Хотите сохранить реплей? Да\Нет"
Если пользователь отвечает : Да, то игра спрашивает у него путь к файлу, куда сохранить игру.
если путь не существует - он должен быть создан автоматически. По этому пути будет сохранен "реплей" -
файл с последовательностью всех действий в игре.


Когда игра запускается - она спрашивает у пользователя: начать новую игру или воспроизвести сохраненную?
Если пользователь выбрал воспроизведение сохраненной игры - игра спрашивает путь к реплею и начинает его воспроизводить.
Это выглядит, как обычная игра, только все действия беруться не случайно, а воспроизводятся строго в том порядке, в котором они были во время оригинальной игры.

Советы:
- Вам нужно будет разработать свой формат реплея и сохранить его в файл. Вы можете использовать стандартную сериализацию Java, но я вам не советую.
Кто знает, может в следующем задании нужно будет сделать поддержку работы в браузере или на iPhone, которые не умеют работать с сериализованными файлами Java.
- Рекомендую весь реплей хранить в виде списка "действий" и сделать несколько подтипов:
-MonsterAction - ход монстра. Могут быть поля - цель атаки и урон.
- WizardAction - могут быть поля, заклинание, цели атаки.

- Вы можете немного переписать вашу исходную игру, чтобы она не напрямую определяла текущее действие,
а через интерфейс ActionProducer.
Тогда сделав две реализации:
- ReplayActionProducer
- RandomGameActionProducer

Вы сможете проигрывать игру или начинать новую, не сильно изменяя существующий код.
+ Позднее вы можете добавить новых поставщиков событий (например, искуственный интеллект разного уровня сложности или человека)




